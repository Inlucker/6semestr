Лаба 7

Что даёт монтирование файловой системы

точка входа - init exit, mount kill_sb
загрузить выгрузить
два раза маунт директории
логи
зачем owner this module
что позволяет file_system_type - описание типа файловой системы, можем зарегистрировать свою файловую систему
Поле owner отвечает за счетчик ссылок на модуль, чтобы его нельзя было случайно выгрузить.
Остальное хз
mount и kill_sb два поля хранящие указатели на функции. Первая функция будет вызвана при монтировании файловой системы, а вторая при размонтировании.

* смонтируй 2 раза
смонтировал

* покажи кол-во ссылок
lsmod | grep vfs (число 2 показываешь)

* когда можно будет выгрузить ваш модуль?
когда счетчик ссылок будет равен 0

* а где это контролируется?
.OWNER поле при ините 99

* а зачем нужен суперблок?
суперблок описывает подмонтированную ФС

* покажите у себя в коде, где вы инитите суперблок
показываешь 55-56

* а что такое block
блок — минимальная единица адресации

* а зачем мы ему задаем PAGE_SIZE
физическая память выделется страницами

* для чего монитруем фс?
чтобы получить доступ к файлам

Виртуальная файловая система - файловая система которая не связана с внешними блочными устройствами и хранит файлы в оперативной памяти
не хранит данные во вторичной памяти
Создание ВФС
1. инициализировать поля структуры file_system_type, которая описывает тип файловой системы
2. зарегистрировать фс
3. подмонтироввать фс чтобы получить доступ к файлам фс

sb Описывает подмонтированную фс

mount нужен чтобы сделать виртуальное адресное пространство доступным

Файл - любая поименнованная совокупность данных, хранимая во вторичной памяти, способная хранить любые данные

Файловая система - порядок определяющий способ организации хранения, именнования и предоставления доступа к информации на вторичных устройствах хранения данных

Поскольку фс не связана с внешними устройствами, используем mount_nodev
inode для корневого каталога (чтобы у примонтированной фс был свой корневой каталог)
для с оздания кэша slab


Лаба 7
Вопросы
Точки входа в программу:
-module_init (при загрузке модуля)
-module_exit (при выгрузке модуля)

Минимальный набор действий для создания VFS:
1) инициализировать поля структуры file_system_type, которая описывает тип файловой системы
2) зарегистрировать файловую систему (функция register_filesystem)
3) подмонтировать файловую систему, чтобы с ней можно было работать

static struct file_system_type mnfs_type = {
.owner = THIS_MODULE,
.name = "mnfs",
.mount = mnfs_mount,
.kill_sb = kill_anon_super,
};
Поле owner хранит кол-во ссылок на модуль, чтобы нельзя было выгрузить модуль, когда ФС подмонтированы и используются. Соответственно сначала отмонтируем ФС, а затем выгружаем модуль.
Поле mount - функция, которая вызывается при подмонтировании ФС (мы пишем свою)
Поле mount - функция, которая вызывается при размонтировании ФС (используем по дефолту)
Заполнение суперблока (функция mnfs_fill_sb). Зачем нужна структура: описывает подмонтированные ФС
Поле blocksize в суперблоке описывает минимальный размер адресации на диске. Присваиваем ему значение PAGE_SIZE, т.к. физическая память выделяется страницами.
Какие структуры нам пришлось инициализировать:
- тип ФС (file_system_type)
- суперблок (super_block)
- операции на суперблоке (super_operations)
* айнод (в данном конкретном случае он описывает корневой каталог)
Tasks:
загрузить выгрузить
два раза маунт директории
логи
зачем owner this module
что позволяет file_system_type - описание типа файловой системы, можем зарегистрировать свою файловую систему
Поле owner отвечает за счетчик ссылок на модуль, чтобы его нельзя было случайно выгрузить.
Остальное хз
mount и kill_sb два поля хранящие указатели на функции. Первая функция будет вызвана при монтировании файловой системы, а вторая при размонтировании.
* смонтируй 2 раза
смонтировал
* покажи кол-во ссылок
lsmod | grep vfs (число 2 показываешь)
* когда можно будет выгрузить ваш модуль?
когда счетчик ссылок будет равен 0
* а где это контролируется?
.OWNER поле при ините 99
* а зачем нужен
суперблок?
суперблок описывает подмонтированную ФС
* покажите у себя в коде, где вы инитите суперблок
показываешь 55-56
* а что такое block
блок — минимальная единица адресации
* а зачем мы ему задаем PAGE_SIZE
физическая память выделется страницами
* для чего монитруем фс?
чтобы получить доступ к файлам

Виртуальная файловая система - файловая система которая не связана с внешними блочными устройствами и хранит файлы в оперативной памяти
не хранит данные во вторичной памяти
Создание ВФС
1. инициализировать поля структуры file_system_type, которая описывает тип файловой системы
2. зарегистрировать фс
3. подмонтироввать фс чтобы получить доступ к файлам фс

sb Описывает подмонтированную фс
mount нужен чтобы сделать виртуальное адресное пространство доступным
Файл - любая поименнованная совокупность данных, хранимая во вторичной памяти, способная хранить любые данные
Файловая система - порядок определяющий способ организации хранения, именнования и предоставления доступа к информации на вторичных устройствах хранения данных

Поскольку фс не связана с внешними устройствами, используем mount_nodev
inode для корневого каталога (чтобы у примонтированной фс был свой корневой каталог)
для создания кэша slab

Вопросы
Число двойка, когда увеличивается (монтируем свою файловую систему)
Выгрузим, когда количество ссылок равно нулю - когда отсортируем все наши файловые системы
Действия в коде которые поваляют монтировать файловую систему (регистрируем функцию mount в системе, регистрируем файловую систему, монтируем файловую систему)
Почему вызываем mount-nodev(является виртуальной, не связана с внешними устройствами, хранит файл в оперативной памяти)
