Лаба 1
Запустить перед сдачей
1) id процесса id группы id сессии - 3 одинаковые (лидер группы лидер сессии и в этой группе он один)
2) Показать информацию о демоне в системе
почему у демона такой parent id? - завершили процесс потомок, демон усиротел и произошло усыновление терминальным процессом
3) функцией demonize создаем новый процесс и завершаем процесс предок
4) id группы - демон один в своей группы
5) ? отсутствует управляющий терминала
6) -1 около tpgid означает что у него нет терминала и нет терминальной группы
7) S/s/L - что означает
S - interruptable sleep большую часть времени они спят - прерываемый сон
s - лидер сесиии
L - процесс многопоточен
8) точка в коде где процесс становится демоном - вызов функции демонайз
9) функция алреади ранинг - обеспечить запуск процесса в одном экземпляре, делается с помощью открытия файла и записи туда id процесса
10) системный вызов control в lockfile передаем дескриптор файла и ключ сет лок и указатель на структуру в которой блокируем файл на запись
11) условие вызова set sid процесс должен быть лидером группы, завершаем процесс родитель
функция setsid делает лидером группы и лидером сессии и отбирает управляющий терминал
12) отбираем управляющий терминал потому что демоны предназначены для выполнения определенных функций связаных с сервисом и влиять на него работу через терминал запрещено
13) где мы запускаем дополнительный поток??
какие действия sighub?????
в демоне устанавливаем игнорирование сигхаб почему?
Сигхаб - сигнал который сообщает процессу о потеря управляющего терминала
У демонов нет управляющего терминала поэтому мы отключаем реакцию на сигхаб
Сетсид блокирует обработку сигхаба, перед тем как вызвать сетсид убиваем предка
в мейне восстанавливается реагция на сигхаб по умолчанию

1) Что нужно сделать перед вызовом setsid - создать новый процесс потомок и завершить процесс предок
2) Что делаем с сигналом sighub в функции daemonize и что это за сигнал. - сигнал, который процесс получает если он утратил управляющий терминал (процесс завершается), чтобы этого не произошло используем функцию sig_action, которая в результате вызова будет игнорировать сигнал сигах
3) У вас установлен странный pid, почему? - Процесс предок завершили и произошло усыновление каким-то user-init/shell-portal
4) umask из какого процесса вызываем из parent'а или из child'а, (из parant'а)
почему из parent'а? (Для сбрасывания режима создания файлов)
(Это возможно потому что потомок унаследует сброшенную маску)
5) Самое важное в структуре... - то что файл блокируется
6) Что нужно сделать с дескрипторами открытых файлов (~закрыть)
7) Что вы делаете с сигналом, чтобы его обрабатывать?
8) Файл блокировки надо удалять (remove();)


Лаба2

1) lstat вовращает ошибку
2) текущий файл не каталог (проверка s_isdir)
3) проверки chdir, closedir, opendir

чтобы установить рабочий каталог и использовать короткое имя файла

Рекурсия/итерация (андрей рекурсия: 1) условия выхода по коду - первое условие елстат вернуло ошибку (посмотреть ошибки возвращаемые элстатом) второе условие - если текущий каталог не является директорией дополнительно проверяем макрос исдир, по проверке исдир выводит файлы на экран?? 2) полное имя файла находится )
Стек правила (когда кладет? начинает выбирать? где видно взятие из стека? где вызывается пуш? где цикл? сколько циклов? есть ли вложенные циклы?)
цикл пока стек не пуст + цикл пока не дойдешь до конца директории
Стек реализовывать связным списком
В стек кладем информацию о файле чтобы определить


Лаба 3 вариант1
Первый модуль ядра - доступ к структурам ядра описывающих процессы
Какие функции ядра используем в этом модуле - принтк и некст таск (Получить следующий процесс в кольцевом списке процессов - двусвязный список)
Какие структуры ядра использовали - predtask и что-то ещё inittask
Объявляем указатель на дескриптор процесса (старкттаск)
Дополнительно для процесса выводим Стейт и прио (прио 120)
Когда вызввается функция инит (когда вызываем инс мод)
Когда ехит (когда выполянем команду рм мод)
Для чего написали загружаемый модуль ядры (получить доступ к структуре ядра)

Вторая часть демонстрирует взаимодействие модулей ядра
Как могут взаимодейстовать модули ядра (обращаясь к данным/ через данные) взаимодействие с помощью разделяемых переменных/памяти
Какие действия нужно выполнить (нужно объявить их с мод extern передать имя данных в макрос export_symbol, эти данные нужно описать в заголовочном файле, который требуется включить в модуль где они будут использоваться)


Лаба 3 вариант2
Первый модуль ядра - доступ к структурам ядра описывающих процессы
Какие функции ядра используем в этом модуле - принтк и некст таск
Объявляем указатель на дескриптор процесса (старкттаск)
Дополнительно для процесса выводим Стейт и прио (прио 120 )

Когда вызввается функция инит (когда вызываем инс мод)
Когда ехит (когда выполянем команду рм мод)
показать код и функции ядра используюмые в модуле ()
Для чего написали загружаемый модуль ядры (получить доступ к структуре ядра)
Вторая часть демонстрирует взаимодействие модулей ядра
Как могут взаимодейстовать модули ядра
(обращаясь к данным/ через данные)
Какие системные вызовы используются


Лаба 4
Proc - виртуальная файловая система (потому что не хранится на жестких носителях, создается на лету при обращении)
Файл - поименованная совокупность данных во вторичной памяти
Нужна для предоставления процессам информации о ресурсах и о самих процессах
Специальный интерфейс Proc предоставляет интерфейс ядра и при этом использует стандартный интерфейс файловой системы
Cmdline - путь к директории процесса
Cwd - символическая ссылка
Environ - содержит большой объем информации, список окр-я процесса
Exe - указывает на образ процесса, путь к исполняемому файлу
Fd - содержит ссылки на открытые процессом файлы
Root - информация о корневом каталоге
Stat - объемная информация о процессе
Statm - информация об использовании памяти
Io - статистическая информация о работе процесса ввода вывода
Maps - регионы вирт адресного пространства выделенного процессу
1 поле - адрес
2 поле - права доступа
3 поле - смещение
4 поле старшие и младшие номера устройств
5 поле inode, pathname
Pagemap - статистика о страницах
Что анализируете - виртуальную файловую систему proc
Почему столько регионов heap - 


Лаба 4 вторая часть
Показать dmesg

copy_to_user функция для передачи информации из пространства ядра в пространство пользователя, используем данную функцию поскольку страницы пространства пользователя могут быть выгружены из памяти. Процесс имеет виртуальное адресное пространство, ядро физическое. При попытке обратиться из ядра к буферу страница может быть выгружена.

copy_from_user функция из пространства пользователя в пространство ядра используем данную функцию посколько приложение и ядро имеют разные уровни привилегии (прил - 3, ядро- 0) для безопасности


Лаба 7

Что даёт монтирование файловой системы

точка входа - init exit, mount kill_sb
загрузить выгрузить
два раза маунт директории
логи
зачем owner this module
что позволяет file_system_type - описание типа файловой системы, можем зарегистрировать свою файловую систему
Поле owner отвечает за счетчик ссылок на модуль, чтобы его нельзя было случайно выгрузить.
Остальное хз
mount и kill_sb два поля хранящие указатели на функции. Первая функция будет вызвана при монтировании файловой системы, а вторая при размонтировании.

* смонтируй 2 раза
смонтировал

* покажи кол-во ссылок
lsmod | grep vfs (число 2 показываешь)

* когда можно будет выгрузить ваш модуль?
когда счетчик ссылок будет равен 0

* а где это контролируется?
.OWNER поле при ините 99

* а зачем нужен суперблок?
суперблок описывает подмонтированную ФС

* покажите у себя в коде, где вы инитите суперблок
показываешь 55-56

* а что такое block
блок — минимальная единица адресации

* а зачем мы ему задаем PAGE_SIZE
физическая память выделется страницами

* для чего монитруем фс?
чтобы получить доступ к файлам

Виртуальная файловая система - файловая система которая не связана с внешними блочными устройствами и хранит файлы в оперативной памяти
не хранит данные во вторичной памяти
Создание ВФС
1. инициализировать поля структуры file_system_type, которая описывает тип файловой системы
2. зарегистрировать фс
3. подмонтироввать фс чтобы получить доступ к файлам фс

sb Описывает подмонтированную фс

mount нужен чтобы сделать виртуальное адресное пространство доступным

Файл - любая поименнованная совокупность данных, хранимая во вторичной памяти, способная хранить любые данные

Файловая система - порядок определяющий способ организации хранения, именнования и предоставления доступа к информации на вторичных устройствах хранения данных

Поскольку фс не связана с внешними устройствами, используем mount_nodev
inode для корневого каталога (чтобы у примонтированной фс был свой корневой каталог)
для с оздания кэша slab


Лаба 7
Вопросы
Точки входа в программу:
-module_init (при загрузке модуля)
-module_exit (при выгрузке модуля)

Минимальный набор действий для создания VFS:
1) инициализировать поля структуры file_system_type, которая описывает тип файловой системы
2) зарегистрировать файловую систему (функция register_filesystem)
3) подмонтировать файловую систему, чтобы с ней можно было работать

static struct file_system_type mnfs_type = {
.owner = THIS_MODULE,
.name = "mnfs",
.mount = mnfs_mount,
.kill_sb = kill_anon_super,
};
Поле owner хранит кол-во ссылок на модуль, чтобы нельзя было выгрузить модуль, когда ФС подмонтированы и используются. Соответственно сначала отмонтируем ФС, а затем выгружаем модуль.
Поле mount - функция, которая вызывается при подмонтировании ФС (мы пишем свою)
Поле mount - функция, которая вызывается при размонтировании ФС (используем по дефолту)
Заполнение суперблока (функция mnfs_fill_sb). Зачем нужна структура: описывает подмонтированные ФС
Поле blocksize в суперблоке описывает минимальный размер адресации на диске. Присваиваем ему значение PAGE_SIZE, т.к. физическая память выделяется страницами.
Какие структуры нам пришлось инициализировать:
- тип ФС (file_system_type)
- суперблок (super_block)
- операции на суперблоке (super_operations)
* айнод (в данном конкретном случае он описывает корневой каталог)
Tasks:
загрузить выгрузить
два раза маунт директории
логи
зачем owner this module
что позволяет file_system_type - описание типа файловой системы, можем зарегистрировать свою файловую систему
Поле owner отвечает за счетчик ссылок на модуль, чтобы его нельзя было случайно выгрузить.
Остальное хз
mount и kill_sb два поля хранящие указатели на функции. Первая функция будет вызвана при монтировании файловой системы, а вторая при размонтировании.
* смонтируй 2 раза
смонтировал
* покажи кол-во ссылок
lsmod | grep vfs (число 2 показываешь)
* когда можно будет выгрузить ваш модуль?
когда счетчик ссылок будет равен 0
* а где это контролируется?
.OWNER поле при ините 99
* а зачем нужен
суперблок?
суперблок описывает подмонтированную ФС
* покажите у себя в коде, где вы инитите суперблок
показываешь 55-56
* а что такое block
блок — минимальная единица адресации
* а зачем мы ему задаем PAGE_SIZE
физическая память выделется страницами
* для чего монитруем фс?
чтобы получить доступ к файлам

Виртуальная файловая система - файловая система которая не связана с внешними блочными устройствами и хранит файлы в оперативной памяти
не хранит данные во вторичной памяти
Создание ВФС
1. инициализировать поля структуры file_system_type, которая описывает тип файловой системы
2. зарегистрировать фс
3. подмонтироввать фс чтобы получить доступ к файлам фс

sb Описывает подмонтированную фс
mount нужен чтобы сделать виртуальное адресное пространство доступным
Файл - любая поименнованная совокупность данных, хранимая во вторичной памяти, способная хранить любые данные
Файловая система - порядок определяющий способ организации хранения, именнования и предоставления доступа к информации на вторичных устройствах хранения данных

Поскольку фс не связана с внешними устройствами, используем mount_nodev
inode для корневого каталога (чтобы у примонтированной фс был свой корневой каталог)
для создания кэша slab

Вопросы
Число двойка, когда увеличивается (монтируем свою файловую систему)
Выгрузим, когда количество ссылок равно нулю - когда отсортируем все наши файловые системы
Действия в коде которые поваляют монтировать файловую систему (регистрируем функцию mount в системе, регистрируем файловую систему, монтируем файловую систему)
Почему вызываем mount-nodev(является виртуальной, не связана с внешними устройствами, хранит файл в оперативной памяти)


Лаба 8
*Показать в коде что линия прерывания разделяется
-(IRQ_SHARED)

*Когда выполняется обработчик прерывания?
-При возникновении прерывания при отпускания клавиши

*Когда выполняется тасклет?
-После обработчика аппаратного прерывания

*Когда выполняется work?
-Когда до неё дойдёт очередь

* чем характеризуется аппаратное прерывание:
-когда выполняется аппаратное прерывание, то другие прерывания запрещены на данном процессоре,
-а на других процессорах тоже запрещены на данной линии IRQ

*полный контекст - аппаратный + указатели на структуры ядра, которые описывают выделенные процессу ресурсы

*аппаратный контекст - содержимое регистров, которые нужно сохранить для продолжения выполнения процесса

*линия irq - выделенная линия, по которой обработчику прерываний передаётся информация о прерывании

*request_irq - регистрация обработчика прерывания
*KEYB_IRQ - номер irq
*(irq_handler_t) interrupt_handler - наш обработчик
*"tasklet", /*имя устройства*/
*(void*) (interrupt_handler)); // адресс обработчика прерывания

*Структура тасклета
-state - состояние тасклета (0 - не запланирован, 1 - запланирован на выполнение, 2 - выполняется)
-count - счетчик ссылок на тасклет
-data - аргумент функции обработчика тасклета

*tasklet_schedule - запланировать тасклет на выполнение

*первый воркер обрабатывает нажатие клавиши, выводит, какая клавиша нажата

*второй воркер блокируется, выводит до и после блокировки

*чем отличается тасклет от воркера?
-тасклет - выполняется в контексте прерывания, поэтому его нельзя заблокировать
-воркер - выполняется в контексте потоков ядра, поэтому его можно заблокировать

*На каком процессе по умолчанию тасклет
-на том, на котором выполняется аппаратное прерывание

*Выделенная линия irq - эта та линия, на которую конкретное устройство посылает сигнал прерываний.
Она выделяется конкретному устройству и по этой линии устройство посылает сигнал прерывания на контроллер прерывания.

*Драйверы регистрируют обработчик аппаратного прерывания и
разрешают определенную линию irq посредством функции request_irq

*какие действия вы выполняете в вашем обработчике аппаратного прерывания
-планируем отложенный вызов, то есть тасклет

*покажите, что ваши линии irq разделяются, какой флаг для этого использовали и где
-(IRQ_SHARED) 61 строка тасклет

*сколько у вас workов
-2

*shedule - планирует выполнение аппартного прерывания

*какие действия нужно выполнить, чтобы ваши workи в итоге выполнились (work)
-инициализирую модуль
-создаем очередь
-инициализируем work
-добавляем в очередь

*покажите код вашего обработчика аппаратного прерывания
-interrupt_handler

*что вы сделали чтобы зарегистрировать в системе свой обработчик аппаратного прерывания и обработчик какого прерывания
-вызвали request_irq

*когда будет выполнен ваш тасклет и на каком процессоре
-по завершению обработчика аппаратного прерывания. На том, на котором выполняется аппаратное прерывание


*Цирюлик 160 - тасклет 162 - очереди

*Разделяет Установленный в системе и наш

Вопросы:
2 в Стейт что означает - тасклет выполняется
Тасклет может быть запланирован много раз, выполнен только 1
Когда вызывается аппаратное прерывание - по отжатии клавиши

Что делаем в своем обработчике аппаратного прерывания с тасклетом - планируем (tasklet_schedule)
Будет выполнен после завершения работы обработчика аппаратного прерывания, на том же процессоре на котором выполнялся наш обработчик
Действия по коду:
Инициализируем тасклет
С помощью request_irq регистрируем в системе свой обработчик аппаратного прерывания, передаем my_handler
В my_hadler планируем тасклет (tasklet_schedule)

Воркеры:

Где можем увидеть в системе данный обработчик прерывания (cat /proc/interrupts) - демонстрирует что линия irq разделяется между определенным по умолчанию в системе обработчиком прерывания и нашим обработчиком
Где это написано в коде - устанавливаем флаг irq_shared в функции request_irq (кроме того передаем номер линии irq, наша функция обработки прерывания, имя устройства, адрес обработчика прерывания)
Какие
действия надо выполнить по коду -
создаем очередь,
инициализируем воркеров,
Ставим воркеров в очередь
Когда будут выполнены, кто запланирует, показать в системе


Лаба 9 (Сокеты)
Системные вызовы:
socket - создает дескриптор сокета
(Передается домен, тип и протокол по умолчанию)

bind - присваивает адрес сокету

(listen - заявляет о желании сервера принимать запросы на установление соединения)
listen - указывает ОС, что сокет переходит в режим пассивного прослушивания соединений.

select - (вообще) позволяет производить мультиплексирование ввода/вывода
select - определяет момент когда можно принять/послать данные
(можно использовать для ожидания прибытия запросов)

connect - создает соединение между клиентом и сервером

Accept
Создает копию исходного сокета который остается в состоянии прослушивания (listen), а сокет созданный accept будет в состоянии подключен (connected)

close - освобождает сокет

Файл - это Любая поименованная совокупность данных, хранящаяся во вторичной памяти

***
(Позволяет реализовать работу ... на отдельно стоящей машине)
***
INADDR_ANY это специальная константа, благодаря которой наша программа сервер зарегистрируется на всех адресах той машины, на которой она выполняется

Unix осущ. взаимодействие через пространство файловых имен

Показать сокет:
ls -ial

Показать ip и порт в системе:
(netstat -tulpn)
sudo ss -tulpn

Что передаем в pselect: набор дескрипторов и кол-во проверяемых дескрипторов

Какой выигрышь дает мультиплексер: *меньшее время блокировки*
(Опрашивает все соединения)
(Опрашивается набор, как только возникнет любое соединение ... в результате время блокировки будет меньше)

Мультиплексер блокирует процесс до появления любого первого соединения.
При выходе из функции мультиплексирования сервер получит информацию о готовых к вводу/выводу дескрипторах.
***
До какого момента блокируетя:
Пока один из дескрипторов из набора дескрипторов сокетов не будет готов к выполнению
***

SOCK_STREAM
Обеспечивает создание двусторонних, надёжных потоков байтов на основе установления соединения. Может также поддерживаться механизм внепоточных данных.
SOCK_DGRAM
Поддерживает дейтаграммы (ненадежные сообщения с ограниченной длиной без установки соединения).

Сама функция select() – блокирующая, она возвращает управление, если хотя бы один из проверяемых сокетов готов к выполнению соответствующей операции.